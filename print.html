<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>TaskChampion</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="welcome.html"><strong aria-hidden="true">1.</strong> Welcome to TaskChampion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="using-task-command.html"><strong aria-hidden="true">1.2.</strong> Using the Task Command</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config-file.html"><strong aria-hidden="true">1.2.1.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="reports.html"><strong aria-hidden="true">1.2.2.</strong> Reports</a></li><li class="chapter-item expanded "><a href="tags.html"><strong aria-hidden="true">1.2.3.</strong> Tags</a></li><li class="chapter-item expanded "><a href="environment.html"><strong aria-hidden="true">1.2.4.</strong> Environment</a></li><li class="chapter-item expanded "><a href="task-sync.html"><strong aria-hidden="true">1.2.5.</strong> Synchronization</a></li></ol></li><li class="chapter-item expanded "><a href="running-sync-server.html"><strong aria-hidden="true">1.3.</strong> Running the Sync Server</a></li></ol></li><li class="chapter-item expanded "><a href="internals.html"><strong aria-hidden="true">2.</strong> Internal Details</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data-model.html"><strong aria-hidden="true">2.1.</strong> Data Model</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="storage.html"><strong aria-hidden="true">2.1.1.</strong> Replica Storage</a></li><li class="chapter-item expanded "><a href="taskdb.html"><strong aria-hidden="true">2.1.2.</strong> Task Database</a></li><li class="chapter-item expanded "><a href="tasks.html"><strong aria-hidden="true">2.1.3.</strong> Tasks</a></li></ol></li><li class="chapter-item expanded "><a href="sync.html"><strong aria-hidden="true">2.2.</strong> Synchronization and the Sync Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sync-model.html"><strong aria-hidden="true">2.2.1.</strong> Synchronization Model</a></li><li class="chapter-item expanded "><a href="sync-protocol.html"><strong aria-hidden="true">2.2.2.</strong> Server-Replica Protocol</a></li><li class="chapter-item expanded "><a href="plans.html"><strong aria-hidden="true">2.2.3.</strong> Planned Functionality</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">TaskChampion</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="taskchampion"><a class="header" href="#taskchampion">TaskChampion</a></h1>
<p>TaskChampion is a personal task-tracking tool.
It works from the command line, with simple commands like <code>ta add &quot;fix the kitchen sink&quot;</code>.
It can synchronize tasks on multiple devices, and does so in an &quot;offline&quot; mode so you can update your tasks even when you can't reach the server.
If you've heard of <a href="https://taskwarrior.org/">TaskWarrior</a>, this tool is very similar, but with some different design choices and greater reliability.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<blockquote>
<p>NOTE: TaskChampion is still in development and not yet feature-complete.
This section is limited to completed functionality.</p>
</blockquote>
<p>Once you've <a href="./installation.html">installed TaskChampion</a>, your interface will be via the <code>ta</code> command.
Start by adding a task:</p>
<pre><code class="language-shell">$ ta add learn how to use taskchampion
added task ba57deaf-f97b-4e9c-b9ab-04bc1ecb22b8
</code></pre>
<p>You can see all of your pending tasks with <code>ta next</code>, or just <code>ta</code> for short:</p>
<pre><code class="language-shell">$ ta
 Id Description                    Active  Tags
 1  learn how to use taskchampion
</code></pre>
<p>Tell TaskChampion you're working on the task, using the shorthand id:</p>
<pre><code class="language-shell">$ ta start 1
</code></pre>
<p>and when you're done with the task, mark it as complete:</p>
<pre><code class="language-shell">$ ta done 1
</code></pre>
<h2 id="synchronizing"><a class="header" href="#synchronizing">Synchronizing</a></h2>
<p>Even if you don't have a server, it's a good idea to sync your task database periodically.
This acts as a backup and also enables some internal house-cleaning.</p>
<pre><code class="language-shell">$ ta sync
</code></pre>
<p>Typically sync is run from a crontab, on whatever schedule fits your needs.</p>
<p>To synchronize multiple replicas of your tasks, you will need a sync server and a client key for that server.
Configure these in <code>~/.config/taskchampion.yml</code>, for example:</p>
<pre><code class="language-yaml">server_client_key: &quot;f8d4d09d-f6c7-4dd2-ab50-634ed20a3ff2&quot;
server_origin: &quot;https://taskchampion.example.com&quot;
</code></pre>
<p>The next run of <code>ta sync</code> will upload your task history to that server.
Configuring another device identically and running <code>ta sync</code> will download that task history, and continue to stay in sync with subsequent runs of the command.</p>
<p>See <a href="./using-task-command.html">Usage</a> for more detailed information on using TaskChampion.</p>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>As this is currently in development, installation is by cloning the repository and running &quot;cargo build&quot;.</p>
<h1 id="using-the-task-command"><a class="header" href="#using-the-task-command">Using the Task Command</a></h1>
<p>The main interface to your tasks is the <code>ta</code> command, which supports various subcommands such as <code>add</code>, <code>modify</code>, <code>start</code>, and <code>done</code>.
Customizable <a href="./reports.html">reports</a> are also available as subcommands, such as <code>next</code>.
The command reads a <a href="./config-file.html">configuration file</a> for its settings, including where to find the task database.
And the <code>sync</code> subcommand <a href="./task-sync.html">synchronizes tasks with a sync server</a>.
You can find a list of all subcommands, as well as the built-in reports, with <code>ta help</code>.</p>
<blockquote>
<p>NOTE: the <code>task</code> interface does not precisely match that of TaskWarrior.</p>
</blockquote>
<h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>The <code>ta</code> command will work out-of-the-box with no configuration file, using default values.</p>
<p>Configuration is read from <code>taskchampion.toml</code> in your config directory.
On Linux systems, that directory is <code>~/.config</code>.
On OS X, it's <code>~/Library/Preferences</code>.
On Windows, it's <code>AppData/Roaming</code> in your home directory.
This can be overridden by setting <code>TASKCHAMPION_CONFIG</code> to the configuration filename.</p>
<p>The file format is <a href="https://toml.io/">TOML</a>.
For example:</p>
<pre><code class="language-toml">data_dir = &quot;/home/myuser/.tasks&quot;
</code></pre>
<h2 id="directories"><a class="header" href="#directories">Directories</a></h2>
<ul>
<li><code>data_dir</code> - path to a directory containing the replica's task data (which will be created if necessary).
Default: <code>taskchampion</code> in the local data directory.</li>
</ul>
<h2 id="sync-server"><a class="header" href="#sync-server">Sync Server</a></h2>
<p>If using a local server:</p>
<ul>
<li><code>server_dir</code> - path to a directory containing the local server's data.
This is only used if <code>server_origin</code> or <code>server_client_key</code> are not set.
Default: <code>taskchampion-sync-server</code> in the local data directory.</li>
</ul>
<p>If using a remote server:</p>
<ul>
<li><code>server_origin</code> - Origin of the TaskChampion sync server, e.g., <code>https://taskchampion.example.com</code>.
If not set, then sync is done to a local server.</li>
<li><code>encryption_secret</code> - Secret value used to encrypt all data stored on the server.
This should be a long random string.
If you have <code>openssl</code> installed, a command like <code>openssl rand -hex 35</code> will generate a suitable value.
This value is only used when synchronizing with a remote server -- local servers are unencrypted.
Treat this value as a password.</li>
<li><code>server_client_key</code> -  Client key to identify this replica to the sync server (a UUID)
If not set, then sync is done to a local server.</li>
</ul>
<h1 id="reports"><a class="header" href="#reports">Reports</a></h1>
<ul>
<li><code>reports</code> - a mapping of each report's name to its definition.
See <a href="./reports.html">Reports</a> for details.</li>
</ul>
<h1 id="reports-1"><a class="header" href="#reports-1">Reports</a></h1>
<p>As a to-do list manager, listing tasks is an important TaskChampion feature.
Reports are tabular displays of tasks, and allow very flexible filtering, sorting, and customization of columns.</p>
<p>TaskChampion includes several &quot;built-in&quot; reports, as well as supporting custom reports in the <a href="./config-file.html">configuration file</a>.</p>
<h2 id="built-in-reports"><a class="header" href="#built-in-reports">Built-In Reports</a></h2>
<p>The <code>next</code> report is the default, and lists all pending tasks:</p>
<pre><code class="language-text">$ ta
Id Description              Active Tags              
1  learn about TaskChampion        +next
2  buy wedding gift         *      +buy
3  plant tomatoes                  +garden
</code></pre>
<p>The <code>Id</code> column contains short numeric IDs that are assigned to pending tasks.
These IDs are easy to type, such as to mark task 2 done (<code>ta 2 done</code>).</p>
<p>The <code>list</code> report lists all tasks, with a similar set of columns.</p>
<h2 id="custom-reports"><a class="header" href="#custom-reports">Custom Reports</a></h2>
<p>Custom reports are defined in the configuration file's <code>reports</code> table.
This is a mapping from each report's name to its definition.
Each definition has the following properties:</p>
<ul>
<li><code>filter</code> - criteria for the tasks to include in the report (optional)</li>
<li><code>sort</code> - how to order the tasks (optional)</li>
<li><code>columns</code> - the columns of information to display for each task</li>
</ul>
<p>For example:</p>
<pre><code class="language-toml">[reports.garden]
sort = [
    { sort_by = &quot;description&quot; }
]
filter = [
    &quot;status:pending&quot;,
    &quot;+garden&quot;
]
columns = [
    { label = &quot;ID&quot;, property = &quot;id&quot; },
    { label = &quot;Description&quot;, property = &quot;description&quot; },
]
</code></pre>
<p>The filter is a list of filter arguments, just like those that can be used on the command line.
See the <code>ta help</code> output for more details on this syntax.
It will be merged with any filters provided on the command line, when the report is invoked.</p>
<p>The sort order is defined by an array of tables containing a <code>sort_by</code> property and an optional <code>ascending</code> property.
Tasks are compared by the first criterion, and if that is equal by the second, and so on.
If <code>ascending</code> is given, it can be <code>true</code> for the default sort order, or <code>false</code> for the reverse.</p>
<p>In most cases tasks are just sorted by one criterion, but a more advanced example might look like:</p>
<pre><code class="language-toml">[reports.garden]
sort = [
    { sort_by = &quot;description&quot; }
    { sort_by = &quot;uuid&quot;, ascending = false }
]
...
</code></pre>
<p>The available values of <code>sort_by</code> are</p>
<p>(TODO: generate automatically)</p>
<p>Finally, the <code>columns</code> configuration specifies the list of columns to display.
Each element has a <code>label</code> and a <code>property</code>, as shown in the example above.</p>
<p>The avaliable properties are:</p>
<p>(TODO: generate automatically)</p>
<h1 id="tags"><a class="header" href="#tags">Tags</a></h1>
<p>Each task has a collection of associated tags.
Tags are short words that categorize tasks, typically written with a leading <code>+</code>, such as <code>+next</code> or <code>+jobsearch</code>.</p>
<p>Tags are useful for filtering tasks in reports or on the command line.
For example, when it's time to continue the job search, <code>ta +jobsearch</code> will show pending tasks with the <code>jobsearch</code> tag.</p>
<h2 id="allowed-tags"><a class="header" href="#allowed-tags">Allowed Tags</a></h2>
<p>Specifically, tags must be at least one character long and cannot contain whitespace or any of the characters <code>+-*/(&lt;&gt;^! %=~</code>.
The first character cannot be a digit, and <code>:</code> is not allowed after the first character.</p>
<h1 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h1>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>Set <code>TASKCHAMPION_CONFIG</code> to the location of a configuration file in order to override the default location.</p>
<h2 id="terminal-output"><a class="header" href="#terminal-output">Terminal Output</a></h2>
<p>Taskchampion uses <a href="https://github.com/BurntSushi/termcolor">termcolor</a> to color its output.
This library interprets <a href="https://github.com/BurntSushi/termcolor#automatic-color-selection"><code>TERM</code> and <code>NO_COLOR</code></a> to determine how it should behave, when writing to a tty.
Set <code>NO_COLOR</code> to any value to force plain-text output.</p>
<h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<p>Both <code>ta</code> and <code>taskchampion-sync-server</code> use <a href="https://docs.rs/env_logger">env-logger</a> and can be configured to log at various levels with the <code>RUST_LOG</code> environment variable.
For example:</p>
<pre><code class="language-shell">$ RUST_LOG=taskchampion=trace ta add foo
</code></pre>
<p>The output may provide valuable clues in debugging problems.</p>
<h1 id="synchronization"><a class="header" href="#synchronization">Synchronization</a></h1>
<p>A single TaskChampion task database is known as a &quot;replica&quot;.
A replica &quot;synchronizes&quot; its local information with other replicas via a sync server.
Many replicas can thus share the same task history.</p>
<p>This operation is triggered by running <code>ta sync</code>.
Typically this runs frequently in a cron task.
Synchronization is quick, especially if no changes have occurred.</p>
<p>Each replica expects to be synchronized frequently, even if no server is involved.
Without periodic syncs, the storage space used for the task database will grow quickly, and performance will suffer.</p>
<p>By default, TaskChampion syncs to a &quot;local server&quot;, as specified by the <code>server_dir</code> configuration parameter.
Every replica sharing a task history should have precisely the same configuration for <code>server_origin</code>, <code>server_client_key</code>, and <code>encryption_secret</code>.</p>
<p>Synchronizing a new replica to an existing task history is easy: begin with an empty replica, configured for the remote server, and run <code>ta sync</code>.
The replica will download the entire task history.</p>
<p>It is possible to switch a single replica to a remote server by simply configuring for the remote server and running <code>ta sync</code>.
The replica will upload the entire task history to the server.
Once this is complete, additional replicas can be configured with the same settings in order to share the task history.</p>
<h1 id="running-the-sync-server"><a class="header" href="#running-the-sync-server">Running the Sync Server</a></h1>
<blockquote>
<p>NOTE: TaskChampion is still in development and not yet feature-complete.
The server is functional, but lacks any administrative features.</p>
</blockquote>
<p>Run <code>taskchampion-sync-server</code> to start the sync server.
Use <code>--port</code> to specify the port it should listen on, and <code>--data-dir</code> to specify the directory which it should store its data.
It only serves HTTP; the expectation is that a frontend proxy will be used for HTTPS support.</p>
<h1 id="internal-details"><a class="header" href="#internal-details">Internal Details</a></h1>
<p>The following sections get into the details of how TaskChampion works.
None of this information is necessary to use TaskChampion, but might be helpful in understanding its behavior.
Developers of TaskChampion and of tools that integrate with TaskChampion should be familiar with this information.</p>
<h1 id="data-model"><a class="header" href="#data-model">Data Model</a></h1>
<p>A client manages a single offline instance of a single user's task list, called a replica.
This section covers the structure of that data.
Note that this data model is visible only on the client; the server does not have access to client data.</p>
<h1 id="replica-storage"><a class="header" href="#replica-storage">Replica Storage</a></h1>
<p>Each replica has a storage backend.
The interface for this backend is given in <code>crate::taskstorage::Storage</code> and <code>StorageTxn</code>.</p>
<p>The storage is transaction-protected, with the expectation of a serializable isolation level.
The storage contains the following information:</p>
<ul>
<li><code>tasks</code>: a set of tasks, indexed by UUID</li>
<li><code>base_version</code>: the number of the last version sync'd from the server (a single integer)</li>
<li><code>operations</code>: all operations performed since base_version</li>
<li><code>working_set</code>: a mapping from integer -&gt; UUID, used to keep stable small-integer indexes into the tasks for users' convenience.  This data is not synchronized with the server and does not affect any consistency guarantees.</li>
</ul>
<h2 id="tasks"><a class="header" href="#tasks">Tasks</a></h2>
<p>The tasks are stored as an un-ordered collection, keyed by task UUID.
Each task in the database has represented by a key-value map.
See <a href="./tasks.html">Tasks</a> for details on the content of that map.</p>
<h2 id="operations"><a class="header" href="#operations">Operations</a></h2>
<p>Every change to the task database is captured as an operation.
In other words, operations act as deltas between database states.
Operations are crucial to synchronization of replicas, using a technique known as Operational Transforms.</p>
<p>Each operation has one of the forms </p>
<ul>
<li><code>Create(uuid)</code></li>
<li><code>Delete(uuid)</code></li>
<li><code>Update(uuid, property, value, timestamp)</code></li>
</ul>
<p>The Create form creates a new task.
It is invalid to create a task that already exists.</p>
<p>Similarly, the Delete form deletes an existing task.
It is invalid to delete a task that does not exist.</p>
<p>The Update form updates the given property of the given task, where property and value are both strings.
Value can also be <code>None</code> to indicate deletion of a property.
It is invalid to update a task that does not exist.
The timestamp on updates serves as additional metadata and is used to resolve conflicts.</p>
<h1 id="task-database"><a class="header" href="#task-database">Task Database</a></h1>
<p>The task database is a layer of abstraction above the replica storage layer, responsible for maintaining some important invariants.
While the storage is pluggable, there is only one implementation of the task database.</p>
<h2 id="reading-data"><a class="header" href="#reading-data">Reading Data</a></h2>
<p>The task database provides read access to the data in the replica's storage through a variety of methods on the struct.
Each read operation is executed in a transaction, so data may not be consistent between read operations.
In practice, this is not an issue for TaskChampion's purposes.</p>
<h2 id="working-set"><a class="header" href="#working-set">Working Set</a></h2>
<p>The task database maintains the working set.
The working set maps small integers to current tasks, for easy reference by command-line users.
This is done in such a way that the task numbers remain stable until the working set is rebuilt, at which point gaps in the numbering, such as for completed tasks, are removed by shifting all higher-numbered tasks downward.</p>
<p>The working set is not replicated, and is not considered a part of any consistency guarantees in the task database.</p>
<h2 id="modifying-data"><a class="header" href="#modifying-data">Modifying Data</a></h2>
<p>Modifications to the data set are made by applying operations.
Operations are described in <a href="./storage.html">Replica Storage</a>.</p>
<p>Each operation is added to the list of operations in the storage, and simultaneously applied to the tasks in that storage.
Operations are checked for validity as they are applied.</p>
<h1 id="tasks-1"><a class="header" href="#tasks-1">Tasks</a></h1>
<p>Tasks are stored internally as a key/value map with string keys and values.
All fields are optional: the <code>Create</code> operation creates an empty task.
Display layers should apply appropriate defaults where necessary.</p>
<h2 id="atomicity"><a class="header" href="#atomicity">Atomicity</a></h2>
<p>The synchronization process does not support read-modify-write operations.
For example, suppose tags are updated by reading a list of tags, adding a tag, and writing the result back.
This would be captured as an <code>Update</code> operation containing the amended list of tags.
Suppose two such <code>Update</code> operations are made in different replicas and must be reconciled:</p>
<ul>
<li><code>Update(&quot;d394be59-60e6-499e-b7e7-ca0142648409&quot;, &quot;tags&quot;, &quot;oldtag,newtag1&quot;, &quot;2020-11-23T14:21:22Z&quot;)</code></li>
<li><code>Update(&quot;d394be59-60e6-499e-b7e7-ca0142648409&quot;, &quot;tags&quot;, &quot;oldtag,newtag2&quot;, &quot;2020-11-23T15:08:57Z&quot;)</code></li>
</ul>
<p>The result of this reconciliation will be <code>oldtag,newtag2</code>, while the user almost certainly intended <code>oldtag,newtag1,newtag2</code>.</p>
<p>The key names given below avoid this issue, allowing user updates such as adding a tag or deleting a dependency to be represented in a single <code>Update</code> operation.</p>
<h2 id="representations"><a class="header" href="#representations">Representations</a></h2>
<p>Integers are stored in decimal notation.</p>
<p>Timestamps are stored as UNIX epoch timestamps, in the form of an integer.</p>
<h2 id="keys"><a class="header" href="#keys">Keys</a></h2>
<p>The following keys, and key formats, are defined:</p>
<ul>
<li><code>status</code> - one of <code>P</code> for a pending task (the default), <code>C</code> for completed or <code>D</code> for deleted</li>
<li><code>description</code> - the one-line summary of the task</li>
<li><code>modified</code> - the time of the last modification of this task</li>
<li><code>start.&lt;timestamp&gt;</code> - either an empty string (representing work on the task to the task that has not been stopped) or a timestamp (representing the time that work stopped)</li>
<li><code>tag.&lt;tag&gt;</code> - indicates this task has tag <code>&lt;tag&gt;</code> (value is an empty string)</li>
</ul>
<p>The following are not yet implemented:</p>
<ul>
<li><code>dep.&lt;uuid&gt;</code> - indicates this task depends on <code>&lt;uuid&gt;</code> (value is an empty string)</li>
<li><code>annotation.&lt;timestamp&gt;</code> - value is an annotation created at the given time</li>
</ul>
<h1 id="synchronization-and-the-sync-server"><a class="header" href="#synchronization-and-the-sync-server">Synchronization and the Sync Server</a></h1>
<p>This section covers <em>synchronization</em> of <em>replicas</em> containing the same set of tasks.
A replica is can perform all operations locally without connecting to a sync server, then share those operations with other replicas when it connects.
Sync is a critical feature of TaskChampion, allowing users to consult and update the same task list on multiple devices, without requiring constant connection.</p>
<p>This is a complex topic, and the section is broken into several chapters, beginning at the lower levels of the implementation and working up.</p>
<h1 id="synchronization-model"><a class="header" href="#synchronization-model">Synchronization Model</a></h1>
<p>The <a href="./taskdb.html">task database</a> also implements synchronization.
Synchronization occurs between disconnected replicas, mediated by a server.
The replicas never communicate directly with one another.
The server does not have access to the task data; it sees only opaque blobs of data with a small amount of metadata.</p>
<p>The synchronization process is a critical part of the task database's functionality, and it cannot function efficiently without occasional synchronization operations</p>
<h2 id="operational-transforms"><a class="header" href="#operational-transforms">Operational Transforms</a></h2>
<p>Synchronization is based on <a href="https://en.wikipedia.org/wiki/Operational_transformation">operational transformation</a>.
This section will assume some familiarity with the concept.</p>
<h2 id="state-and-operations"><a class="header" href="#state-and-operations">State and Operations</a></h2>
<p>At a given time, the set of tasks in a replica's storage is the essential &quot;state&quot; of that replica.
All modifications to that state occur via operations, as defined in <a href="./storage.html">Replica Storage</a>.
We can draw a network, or graph, with the nodes representing states and the edges representing operations.
For example:</p>
<pre><code class="language-text">  o -- State: {abc-d123: 'get groceries', priority L}
  |
  | -- Operation: set abc-d123 priority to H
  |
  o -- State: {abc-d123: 'get groceries', priority H}
</code></pre>
<p>For those familiar with distributed version control systems, a state is analogous to a revision, while an operation is analogous to a commit.</p>
<p>Fundamentally, synchronization involves all replicas agreeing on a single, linear sequence of operations and the state that those operations create.
Since the replicas are not connected, each may have additional operations that have been applied locally, but which have not yet been agreed on.
The synchronization process uses operational transformation to &quot;linearize&quot; those operations.
This process is analogous (vaguely) to rebasing a sequence of Git commits.</p>
<h3 id="versions"><a class="header" href="#versions">Versions</a></h3>
<p>Occasionally, database states are given a name (that takes the form of a UUID).
The system as a whole (all replicas) constructs a branch-free sequence of versions and the operations that separate each version from the next.
The version with the nil UUID is implicitly the empty database.</p>
<p>The server stores the operations to change a state from a &quot;parent&quot; version to a &quot;child&quot; version, and provides that information as needed to replicas.
Replicas use this information to update their local task databases, and to generate new versions to send to the server.</p>
<p>Replicas generate a new version to transmit local changes to the server.
The changes are represented as a sequence of operations with the state resulting from the final operation corresponding to the version.
In order to keep the versions in a single sequence, the server will only accept a proposed version from a replica if its parent version matches the latest version on the server.</p>
<p>In the non-conflict case (such as with a single replica), then, a replica's synchronization process involves gathering up the operations it has accumulated since its last synchronization; bundling those operations into a version; and sending that version to the server.</p>
<h3 id="replica-invariant"><a class="header" href="#replica-invariant">Replica Invariant</a></h3>
<p>The replica's <a href="./storage.html">storage</a> contains the current state in <code>tasks</code>, the as-yet un-synchronized operations in <code>operations</code>, and the last version at which synchronization occurred in <code>base_version</code>.</p>
<p>The replica's un-synchronized operations are already reflected in its local <code>tasks</code>, so the following invariant holds:</p>
<blockquote>
<p>Applying <code>operations</code> to the set of tasks at <code>base_version</code> gives a set of tasks identical
to <code>tasks</code>.</p>
</blockquote>
<h3 id="transformation"><a class="header" href="#transformation">Transformation</a></h3>
<p>When the latest version on the server contains operations that are not present in the replica, then the states have diverged.
For example:</p>
<pre><code class="language-text">  o  -- version N
 w|\a
  o o
 x|  \b
  o   o
 y|    \c
  o     o -- replica's local state
 z|
  o -- version N+1
</code></pre>
<p>(diagram notation: <code>o</code> designates a state, lower-case letters designate operations, and versions are presented as if they were numbered sequentially)</p>
<p>In this situation, the replica must &quot;rebase&quot; the local operations onto the latest version from the server and try again.
This process is performed using operational transformation (OT).
The result of this transformation is a sequence of operations based on the latest version, and a sequence of operations the replica can apply to its local task database to reach the same state
Continuing the example above, the resulting operations are shown with <code>'</code>:</p>
<pre><code class="language-text">  o  -- version N
 w|\a
  o o
 x|  \b
  o   o
 y|    \c
  o     o -- replica's intermediate local state
 z|     |w'
  o-N+1 o
 a'\    |x'
    o   o
   b'\  |y'
      o o
     c'\|z'
        o  -- version N+2
</code></pre>
<p>The replica applies w' through z' locally, and sends a' through c' to the server as the operations to generate version N+2.
Either path through this graph, a-b-c-w'-x'-y'-z' or a'-b'-c'-w-x-y-z, must generate <em>precisely</em> the same final state at version N+2.
Careful selection of the operations and the transformation function ensure this.</p>
<p>See the comments in the source code for the details of how this transformation process is implemented.</p>
<h2 id="synchronization-process"><a class="header" href="#synchronization-process">Synchronization Process</a></h2>
<p>To perform a synchronization, the replica first requests the child version of <code>base_version</code> from the server (GetChildVersion).
It applies that version to its local <code>tasks</code>, rebases its local <code>operations</code> as described above, and updates <code>base_version</code>.
The replica repeats this process until the server indicates no additional child versions exist.
If there are no un-synchronized local operations, the process is complete.</p>
<p>Otherwise, the replica creates a new version containing its local operations, giving its <code>base_version</code> as the parent version, and transmits that to the server (AddVersion).
In most cases, this will succeed, but if another replica has created a new version in the interim, then the new version will conflict with that other replica's new version and the server will respond with the new expected parent version.
In this case, the process repeats.
If the server indicates a conflict twice with the same expected base version, that is an indication that the replica has diverged (something serious has gone wrong).</p>
<h2 id="servers"><a class="header" href="#servers">Servers</a></h2>
<p>A replica depends on periodic synchronization for performant operation.
Without synchronization, its list of pending operations would grow indefinitely, and tasks could never be expired.
So all replicas, even &quot;singleton&quot; replicas which do not replicate task data with any other replica, must synchronize periodically.</p>
<p>TaskChampion provides a <code>LocalServer</code> for this purpose.
It implements the <code>get_child_version</code> and <code>add_version</code> operations as described, storing data on-disk locally, all within the <code>ta</code> binary.</p>
<h1 id="server-replica-protocol"><a class="header" href="#server-replica-protocol">Server-Replica Protocol</a></h1>
<p>The server-replica protocol is defined abstractly in terms of request/response transactions from the replica to the server.
This is made concrete in an HTTP representation.</p>
<p>The protocol builds on the model presented in the previous chapter, and in particular on the synchronization process.</p>
<h2 id="clients"><a class="header" href="#clients">Clients</a></h2>
<p>From the server's perspective, replicas are indistinguishable, so this protocol uses the term &quot;client&quot; to refer generically to all replicas replicating a single task history.</p>
<p>Each client is identified and authenticated with a &quot;client key&quot;, known only to the server and to the replicas replicating the task history.</p>
<h2 id="server"><a class="header" href="#server">Server</a></h2>
<p>For each client, the server is responsible for storing the task history, in the form of a branch-free sequence of versions.</p>
<p>For each client, it stores a set of versions as well as the latest version ID, defaulting to the nil UUID.
Each version has a version ID, a parent version ID, and a history segment (opaque data containing the operations for that version).
The server should maintain the following invariants:</p>
<ol>
<li>Given a client c, c.latestVersion is nil or exists in the set of versions.</li>
<li>Given versions v1 and v2 for a client, with v1.versionId != v2.versionId and v1.parentVersionId != nil, v1.parentVersionId != v2.parentVersionId.
In other words, versions do not branch.</li>
</ol>
<p>Note that versions form a linked list beginning with the version stored in he client. 
This linked list need not continue back to a version with v.parentVersionId = nil.
It may end at any point when v.parentVersionId is not found in the set of Versions.
This observation allows the server to discard older versions.</p>
<h2 id="transactions"><a class="header" href="#transactions">Transactions</a></h2>
<h3 id="addversion"><a class="header" href="#addversion">AddVersion</a></h3>
<p>The AddVersion transaction requests that the server add a new version to the client's task history.
The request contains the following;</p>
<ul>
<li>parent version ID</li>
<li>history segment</li>
</ul>
<p>The server determines whether the new version is acceptable, atomically with respect to other requests for the same client.
If it has no versions for the client, it accepts the version.
If it already has one or more versions for the client, then it accepts the version only if the given parent version ID matches its stored latest parent ID.</p>
<p>If the version is accepted, the server generates a new version ID for it.
The version is added to the set of versions for the client, the client's latest version ID is set to the new version ID.
The new version ID is returned in the response to the client.</p>
<p>If the version is not accepted, the server makes no changes, but responds to the client with a conflict indication containing the latest version ID.
The client may then &quot;rebase&quot; its operations and try again.
Note that if a client receives two conflict responses with the same parent version ID, it is an indication that the client's version history has diverged from that on the server.</p>
<h3 id="getchildversion"><a class="header" href="#getchildversion">GetChildVersion</a></h3>
<p>The GetChildVersion transaction is a read-only request for a version.
The request consists of a parent version ID.
The server searches its set of versions for a version with the given parent ID.
If found, it returns the version's</p>
<ul>
<li>version ID,</li>
<li>parent version ID (matching that in the request), and</li>
<li>history segment.</li>
</ul>
<p>If not found, the server returns a negative response.</p>
<h2 id="http-representation"><a class="header" href="#http-representation">HTTP Representation</a></h2>
<p>The transactions above are realized for an HTTP server at <code>&lt;origin&gt;</code> using the HTTP requests and responses described here.
The <code>origin</code> <em>should</em> be an HTTPS endpoint on general principle, but nothing in the functonality or security of the protocol depends on connection encryption.</p>
<p>The replica identifies itself to the server using a <code>clientKey</code> in the form of a UUID.
This value is passed with every request in the <code>X-Client-Id</code> header, in its dashed-hex format.</p>
<h3 id="addversion-1"><a class="header" href="#addversion-1">AddVersion</a></h3>
<p>The request is a <code>POST</code> to <code>&lt;origin&gt;/client/add-version/&lt;parentVersionId&gt;</code>.
The request body contains the history segment, optionally encoded using any encoding supported by actix-web.
The content-type must be <code>application/vnd.taskchampion.history-segment</code>.</p>
<p>The success response is a 200 OK with an empty body.
The new version ID appears in the <code>X-Version-Id</code> header.</p>
<p>On conflict, the response is a 409 CONFLICT with an empty body.
The expected parent version ID appears in the <code>X-Parent-Version-Id</code> header.</p>
<p>Other error responses (4xx or 5xx) may be returned and should be treated appropriately to their meanings in the HTTP specification.</p>
<h3 id="getchildversion-1"><a class="header" href="#getchildversion-1">GetChildVersion</a></h3>
<p>The request is a <code>GET</code> to <code>&lt;origin&gt;/client/get-child-version/&lt;parentVersionId&gt;</code>.
The response is 404 NOT FOUND if no such version exists.
Otherwise, the response is a 200 OK.
The version's history segment is returned in the response body, with content-type <code>application/vnd.taskchampion.history-segment</code>.
The version ID appears in the <code>X-Version-Id</code> header.
The response body may be encoded, in accordance with any <code>Accept-Encoding</code> header in the request.</p>
<h1 id="planned-functionality"><a class="header" href="#planned-functionality">Planned Functionality</a></h1>
<p>This section is a bit of a to-do list for additional functionality to add to the synchronzation system.
Each feature has some discussion of how it might be implemented.</p>
<h2 id="snapshots"><a class="header" href="#snapshots">Snapshots</a></h2>
<p>As designed, storage required on the server would grow with time, as would the time required for new clients to update to the latest version.
As an optimization, the server also stores &quot;snapshots&quot; containing a full copy of the task database at a given version.
Based on configurable heuristics, it may delete older operations and snapshots, as long as enough data remains for active clients to synchronize and for new clients to initialize.</p>
<p>Since snapshots must be computed by clients, the server may &quot;request&quot; a snapshot when providing the latest version to a client.
This request comes with a number indicating how much it 'wants&quot; the snapshot.
Clients which can easily generate and transmit a snapshot should be generous to the server, while clients with more limited resources can wait until the server's requests are more desperate.
The intent is, where possible, to request snapshots created on well-connected desktop clients over mobile and low-power clients.</p>
<h2 id="encryption-and-signing"><a class="header" href="#encryption-and-signing">Encryption and Signing</a></h2>
<p>From the server's perspective, all data except for version numbers are opaque binary blobs.
Clients encrypt and sign these blobs using a symmetric key known only to the clients.
This secures the data at-rest on the server.
Note that privacy is not complete, as the server still has some information about users, including source and frequency of synchronization transactions and size of those transactions.</p>
<h2 id="backups"><a class="header" href="#backups">Backups</a></h2>
<p>In this design, the server is little more than an authenticated storage for encrypted blobs provided by the client.
To allow for failure or data loss on the server, clients are expected to cache these blobs locally for a short time (a week), along with a server-provided HMAC signature.
When data loss is detected -- such as when a client expects the server to have a version N or higher, and the server only has N-1, the client can send those blobs to the server.
The server can validate the HMAC and, if successful, add the blobs to its datastore.</p>
<h2 id="expiration"><a class="header" href="#expiration">Expiration</a></h2>
<p>Deleted tasks remain in the task database, and are simply hidden in most views.
All tasks have an expiration time after which they may be flushed, preventing unbounded increase in task database size.
However, purging of a task does not satisfy the necessary OT guarantees, so some further formal design work is required before this is implemented.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
